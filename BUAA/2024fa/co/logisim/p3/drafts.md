# Logisim 单周期 CPU 设计文档

## 接口设计

### Instruction Fetch Unit 取指令单元

| Name |                            Descript.                            | SubModule |
| :--: | :-------------------------------------------------------------: | :-------: |
| IFU  |             取出指定地址的指令，计算下一指令的地址              |  PC, IM   |
|  PC  |      给出待取指令的地址。寄存器实现。起始地址：0x00003000       |     /     |
|  IM  | 存储指令，用 4096x32bit ROM 实现，从 0 开始存储，运行中保持不变 |     /     |

|   Sig   |  Type   |      Descript.       |
| :-----: | :-----: | :------------------: |
|   Clk   |    I    |       内置时钟       |
|   Rst   |    I    |       异步复位       |
|  PCSrc  |    I    |   下一地址来源信号   |
| SignImm | I[31:0] |  有符号 32 位立即数  |
|  Instr  | O[31:0] |         指令         |
|   pc    | O[31:0] | 当前地址，顶层输出用 |

#### Program Counter 程序计数器

|  Sig  |  Type   |   Descript.    |
| :---: | :-----: | :------------: |
|  Clk  |    I    |    内置时钟    |
|  Rst  |    I    |    异步复位    |
| Addr' | I[31:0] | 下一指令的地址 |
| Addr  | O[31:0] | 当前指令的地址 |

#### Instruction Memory 指令存储器

|  Sig  |  Type   |   Descript.    |
| :---: | :-----: | :------------: |
| Addr  | I[31:0] | 待取指令的地址 |
| Instr | O[31:0] |      指令      |

### Splitter 指令分离器

|  Sig   |  Type   |             Descript.             |
| :----: | :-----: | :-------------------------------: |
| Instr  | I[31:0] |               指令                |
|  imm   | O[15:0] |         立即数，ins[15:0]         |
|  addr  | O[25:0] |    地址，跳转指令用，ins[25:0]    |
| funct  | O[5:0]  | R 型指令的 funct 字段码，ins[5:0] |
| shamt  | O[4:0]  |         移位量，ins[10:6]         |
|   rd   | O[4:0]  |     写寄存器地址，ins[15:11]      |
|   rt   | O[4:0]  |    读寄存器 2 地址，ins[20:16]    |
|   rs   | O[4:0]  |    读寄存器 1 地址，ins[25:21]    |
| opcode | O[5:0]  |        指令码，ins[31:26]         |

### General Register File 通用寄存器组

| Name |          Descript.          |
| :--: | :-------------------------: |
| GRF  |  寄存器堆，带写入序号控制   |
|  RF  | 寄存器文件，32 个寄存器实现 |

|   Sig    |  Type   |          Descript.          |
| :------: | :-----: | :-------------------------: |
|   Clk    |    I    |          内置时钟           |
|   Rst    |    I    |          异步复位           |
| RegWrite |    I    |           写使能            |
|  RegDst  |    I    |           写选择            |
|    rd    | I[4:0]  |  写寄存器地址，ins[15:11]   |
|    rt    | I[4:0]  | 读寄存器 2 地址，ins[20:16] |
|    rs    | I[4:0]  | 读寄存器 1 地址，ins[25:21] |
|    WD    | I[31:0] |           写入值            |
|   RD1    | O[31:0] |          读取值 1           |
|   RD2    | O[31:0] |          读取值 2           |
|    RA    | O[4:0]  |  写寄存器地址，顶层输出用   |

#### Register File 寄存器文件

|   Sig    |  Type   | Descript. |
| :------: | :-----: | :-------: |
|   Clk    |    I    | 内置时钟  |
|   Rst    |    I    | 异步复位  |
| RegWrite |    I    |  写使能   |
|    A1    | I[4:0]  |    rs     |
|    A2    | I[4:0]  |    rt     |
|    A3    | I[4:0]  |    rd     |
|    WD    | I[31:0] |  写入值   |
|   RD1    | O[31:0] | 读取值 1  |
|   RD2    | O[31:0] | 读取值 2  |

### Extender 符号扩展单元

| Name |               Descript.                | SubModule |
| :--: | :------------------------------------: | :-------: |
| EXT  | 将 16 位立即数按指定方式扩展到 32 位。 |     /     |

|  Sig   |  Type   |                        Descript.                         |
| :----: | :-----: | :------------------------------------------------------: |
| ExtOp  | I[1:0]  | 00 表示零扩展，01 表示符号扩展，10 表示填至高位，11 待用 |
|  Imm   | I[15:0] |                       16 位立即数                        |
| ExtImm | O[31:0] |                       32 位立即数                        |

### Arithmetic & Logic Unit with Contorl 带控制算术逻辑单元

| Name |          Descript.           | SubModule |
| :--: | :--------------------------: | :-------: |
| ALUC | 算术逻辑单元，带输入选择控制 |    ALU    |
| ALU  |         算术逻辑单元         |     /     |

|   Sig   |  Type   |     Descript.     |
| :-----: | :-----: | :---------------: |
| ALUSrc  |    I    | 选择寄存器/立即数 |
| ALUCtrl | I[2:0]  |   选择运算类型    |
|  SrcA   | I[31:0] |    寄存器值 1     |
|   Dat   | I[31:0] |    寄存器值 2     |
| ExtImm  | I[31:0] |      立即数       |
|  Zero   |    O    |   结果是否为 0    |
| ALURes  | O[31:0] |     运算结果      |

#### Arithmetic & Logic Unit 算术逻辑单元

|   Sig   |  Type   |  Descript.   |
| :-----: | :-----: | :----------: |
| ALUCtrl | I[2:0]  | 选择运算类型 |
|  SrcA   | I[31:0] |  寄存器值 1  |
|  SrcB   | I[31:0] |   运算值 2   |
|  Zero   |    O    | 结果是否为 0 |
| ALURes  | O[31:0] |   运算结果   |

### Data Memory with Control 带控制数据存储器

| Name |         Descript.          | SubModule |
| :--: | :------------------------: | :-------: |
| DMC  | 数据存储器，带输出选择控制 |    DM     |
|  DM  |         数据存储器         |     /     |

|    Sig    |  Type   |        Descript.         |
| :-------: | :-----: | :----------------------: |
|    Clk    |    I    |         内置时钟         |
|    Rst    |    I    |         异步复位         |
| MemWrite  |    I    |          写使能          |
| MemtoReg  |    I    |         输出选择         |
|  ALURes   | I[31:0] |         计算结果         |
| WriteData | I[31:0] |          写入值          |
|  MemAddr  | O[31:0] | 写入内存地址，顶层输出用 |
|  Result   | O[31:0] |          读取值          |

#### Data Memory 数据存储器

| Sig  |  Type   | Descript. |
| :--: | :-----: | :-------: |
| Clk  |    I    | 内置时钟  |
| Rst  |    I    | 异步复位  |
|  WE  |    I    |  写使能   |
| Addr | I[11:0] |   地址    |
|  WD  | I[31:0] |  写入值   |
|  RD  | O[31:0] |  读取值   |

### Control Unit 控制单元

| Name | Descript. | SubModule |
| :--: | :-------: | :-------: |
|  CU  | 控制单元  |     /     |

|   Sig    |  Type  |      Descript.       |
| :------: | :----: | :------------------: |
|   Zero   |   I    | ALU 运算结果是否为 0 |
|  Opcode  | I[5:0] |     opcode 字段      |
|  Funct   | I[5:0] |      funct 字段      |
| MemtoReg |   O    |       选择输出       |
| MemWrite |   O    |      数据写使能      |
|  PCSrc   |   O    |   下一地址来源信号   |
|  ALUSrc  |   O    |  选择寄存器/立即数   |
|  RegDst  |   O    |      选择 rt/rd      |
| RegWrite |   O    |    寄存器堆写使能    |
| ALUCtrl  | O[2:0] |     运算类型选择     |

## 编码

### ALU 编码表

| ALUCtrl |     功能      |
| :-----: | :-----------: |
|   000   | A << B(shamt) |
|   001   |    A OR B     |
|   010   |     A + B     |
|   011   |               |
|   100   |     A - B     |
|   101   |               |
|   110   |               |
|   111   |               |

### 控制单元编码表

|   Op   | OpCode/funct | RegWrite | RegDst | ALUsrc | Branch | MemWrite | MemtoReg | EXTOp | Jump | ALUOp |
| :----: | :----------: | :------: | :----: | :----: | :----: | :------: | :------: | :---: | :--: | :---: |
| R-Type |    000000    |    1     |   1    |   0    |   0    |    0     |    0     |   0   |  0   |       |
|  add   |    100000    |          |        |        |        |          |          |       |      |  010  |
|  sub   |    100010    |          |        |        |        |          |          |       |      |  100  |
|  xor   |    100110    |          |        |        |        |          |          |       |      |  110  |
|   lw   |    100011    |    1     |   0    |   1    |   0    |    0     |    1     |   1   |  0   |  010  |
|   sw   |    101011    |    0     |   0    |   1    |   0    |    1     |    0     |   1   |  0   |  010  |
|  beq   |    000100    |    0     |   0    |   0    |   1    |    0     |    0     |   1   |  0   |  100  |
|  ori   |    001101    |    1     |   0    |   1    |   0    |    0     |    0     |   0   |  0   |  001  |
|  lui   |    001111    |    1     |   0    |   1    |   0    |    0     |    0     |   2   |  0   |  001  |
|   j    |    000010    |    0     |   0    |   0    |   0    |    0     |    0     |   0   |  1   |  001  |

## 测试用例

```asm
.text
ori $t0, $0, 1
ori $t1, $0, 20
ori $s0, $0, 1
main:
ori $1, $0, 1
lui $2, 12834
ori $2, $2, 12300
sw $2, 0($0)
add $0, $0, $2
nop
ori $2, $0, 1000
sw $0, -100($2)
sub $2, $2, $2
ori $2, $2, 10000
sw $2, 0($0)
lw $t3, 0($0)
add $t0, $t0, $s0
beq $t0, $t1, exit
j main
exit:
sw $t0, 100($0)
```

## 思考题

- 请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。
  - 状态存储：IFU, DM, GRF
  - 状态转移：ALU, CU, EXT
- 现在我们的模块中 IM 使用 ROM， DM 使用 RAM， GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。
  - 合理，符合局部性原理
  - 设计更加高速的存储模块以进一步符合局部性原理？
- 你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。
  - Splitter 指令分离器，将 IM 输出的指令分离成各个模块所需的部分
  - 将各个模块与组合电路合成一个模块，顶层设计上看起来更加整洁
- 实现 nop 空指令，我们并不需要将它加入控制信号真值表，为什么？
  - `nop` 等价于 `sll $0, $0, 0`，没有使处理器中任何一部分产生变化。
  - 需要让 ALU 的 `0` 码有对应操作，否则含 `x` 结果无法运行。
- 阅读 Pre 的 “MIPS 指令集及汇编语言” 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。
  - 指令覆盖情况：缺少 `sub`，`j`（自己新增）等指令
  - 单一指令覆盖情况：
    - `add` 缺少最大值
    - `ori` 缺少随机值
    - `lui` 缺少 `0`
    - `lw/sw` 偏移量未考虑负数
    - `beq` 跳转范围不足
